schema {
  query: Query
  mutation: Mutation
}

"The root query type which gives access points into the data universe."
type Query implements Node {
  "Exposes the root query type nested one level down. This is helpful for Relay 1\nwhich can only query top level fields if they are in a particular form."
  query: Query!
  "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
  nodeId: ID!
  "Fetches an object given its globally unique `ID`."
  node("The globally unique `ID`." nodeId: ID!): Node
  "Reads and enables pagination through a set of `Customer`."
  allCustomers("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Customer`." orderBy: [CustomersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: CustomerCondition): CustomersConnection
  "Reads and enables pagination through a set of `Order`."
  allOrders("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderCondition): OrdersConnection
  "Reads and enables pagination through a set of `OrderItem`."
  allOrderItems("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderItemCondition): OrderItemsConnection
  "Reads and enables pagination through a set of `PaymentMethod`."
  allPaymentMethods("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PaymentMethod`." orderBy: [PaymentMethodsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PaymentMethodCondition): PaymentMethodsConnection
  "Reads and enables pagination through a set of `Product`."
  allProducts("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Product`." orderBy: [ProductsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductCondition): ProductsConnection
  "Reads and enables pagination through a set of `ProductCategory`."
  allProductCategories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductCategory`." orderBy: [ProductCategoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductCategoryCondition): ProductCategoriesConnection
  "Reads and enables pagination through a set of `ProductColor`."
  allProductColors("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductColor`." orderBy: [ProductColorsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductColorCondition): ProductColorsConnection
  "Reads and enables pagination through a set of `ProductColorLink`."
  allProductColorLinks("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductColorLinkCondition): ProductColorLinksConnection
  "Reads and enables pagination through a set of `ProductSize`."
  allProductSizes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductSize`." orderBy: [ProductSizesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductSizeCondition): ProductSizesConnection
  "Reads and enables pagination through a set of `ProductSizeLink`."
  allProductSizeLinks("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductSizeLinkCondition): ProductSizeLinksConnection
  "Reads and enables pagination through a set of `StoreOwner`."
  allStoreOwners("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `StoreOwner`." orderBy: [StoreOwnersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: StoreOwnerCondition): StoreOwnersConnection
  customerByCustomerId(customerId: Int!): Customer
  orderByOrderId(orderId: Int!): Order
  orderItemByOrderItemId(orderItemId: Int!): OrderItem
  paymentMethodByPaymentMethodId(paymentMethodId: Int!): PaymentMethod
  productByProductId(productId: Int!): Product
  productCategoryByCategoryId(categoryId: Int!): ProductCategory
  productColorByColorId(colorId: Int!): ProductColor
  productColorLinkByProductColorId(productColorId: Int!): ProductColorLink
  productSizeBySizeId(sizeId: Int!): ProductSize
  productSizeLinkByProductSizeId(productSizeId: Int!): ProductSizeLink
  storeOwnerByOwnerId(ownerId: Int!): StoreOwner
  "Reads a single `Customer` using its globally unique `ID`."
  customer("The globally unique `ID` to be used in selecting a single `Customer`." nodeId: ID!): Customer
  "Reads a single `Order` using its globally unique `ID`."
  order("The globally unique `ID` to be used in selecting a single `Order`." nodeId: ID!): Order
  "Reads a single `OrderItem` using its globally unique `ID`."
  orderItem("The globally unique `ID` to be used in selecting a single `OrderItem`." nodeId: ID!): OrderItem
  "Reads a single `PaymentMethod` using its globally unique `ID`."
  paymentMethod("The globally unique `ID` to be used in selecting a single `PaymentMethod`." nodeId: ID!): PaymentMethod
  "Reads a single `Product` using its globally unique `ID`."
  product("The globally unique `ID` to be used in selecting a single `Product`." nodeId: ID!): Product
  "Reads a single `ProductCategory` using its globally unique `ID`."
  productCategory("The globally unique `ID` to be used in selecting a single `ProductCategory`." nodeId: ID!): ProductCategory
  "Reads a single `ProductColor` using its globally unique `ID`."
  productColor("The globally unique `ID` to be used in selecting a single `ProductColor`." nodeId: ID!): ProductColor
  "Reads a single `ProductColorLink` using its globally unique `ID`."
  productColorLink("The globally unique `ID` to be used in selecting a single `ProductColorLink`." nodeId: ID!): ProductColorLink
  "Reads a single `ProductSize` using its globally unique `ID`."
  productSize("The globally unique `ID` to be used in selecting a single `ProductSize`." nodeId: ID!): ProductSize
  "Reads a single `ProductSizeLink` using its globally unique `ID`."
  productSizeLink("The globally unique `ID` to be used in selecting a single `ProductSizeLink`." nodeId: ID!): ProductSizeLink
  "Reads a single `StoreOwner` using its globally unique `ID`."
  storeOwner("The globally unique `ID` to be used in selecting a single `StoreOwner`." nodeId: ID!): StoreOwner
}

"An object with a globally unique `ID`."
interface Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
}

"A connection to a list of `Customer` values."
type CustomersConnection {
  "A list of `Customer` objects."
  nodes: [Customer]!
  "A list of edges which contains the `Customer` and cursor to aid in pagination."
  edges: [CustomersEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Customer` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ thông tin khách hàng"
type Customer implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã khách hàng (khóa chính)"
  customerId: Int!
  "Tên khách hàng"
  customerName: String
  "Email khách hàng"
  email: String
  "Số điện thoại khách hàng"
  phone: String
  "Địa chỉ khách hàng"
  address: String
  "Ngày tạo tài khoản"
  createDate: Datetime
  "Điểm tích lũy"
  points: Int
  "Reads and enables pagination through a set of `Order`."
  ordersByCustomerId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderCondition): OrdersConnection!
}

"A point in time as described by the [ISO\n8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) standard. May or may not include a timezone."
scalar Datetime

"A connection to a list of `Order` values."
type OrdersConnection {
  "A list of `Order` objects."
  nodes: [Order]!
  "A list of edges which contains the `Order` and cursor to aid in pagination."
  edges: [OrdersEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Order` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ thông tin đơn hàng"
type Order implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã đơn hàng (khóa chính)"
  orderId: Int!
  "Ngày đặt hàng"
  orderDate: Datetime
  "Mã khách hàng (khóa ngoại)"
  customerId: Int
  "Tổng số tiền"
  totalAmount: BigFloat
  "Mã phương thức thanh toán (khóa ngoại)"
  paymentMethodId: Int
  "Trạng thái hoàn tiền"
  isRefunded: Boolean
  "Reads a single `Customer` that is related to this `Order`."
  customerByCustomerId: Customer
  "Reads a single `PaymentMethod` that is related to this `Order`."
  paymentMethodByPaymentMethodId: PaymentMethod
  "Reads and enables pagination through a set of `OrderItem`."
  orderItemsByOrderId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderItemCondition): OrderItemsConnection!
}

"A floating point number that requires more precision than IEEE 754 binary 64"
scalar BigFloat

"Bảng lưu trữ thông tin phương thức thanh toán"
type PaymentMethod implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã phương thức thanh toán (khóa chính)"
  paymentMethodId: Int!
  "Tên phương thức thanh toán"
  paymentMethodName: String
  "Reads and enables pagination through a set of `Order`."
  ordersByPaymentMethodId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderCondition): OrdersConnection!
}

"A location in a connection that can be used for resuming pagination."
scalar Cursor

"Methods to use when ordering `Order`."
enum OrdersOrderBy {
  NATURAL
  ORDER_ID_ASC
  ORDER_ID_DESC
  ORDER_DATE_ASC
  ORDER_DATE_DESC
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  TOTAL_AMOUNT_ASC
  TOTAL_AMOUNT_DESC
  PAYMENT_METHOD_ID_ASC
  PAYMENT_METHOD_ID_DESC
  IS_REFUNDED_ASC
  IS_REFUNDED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `Order` object types. All fields are tested for equality and combined with a logical ‘and.’"
input OrderCondition {
  "Checks for equality with the object’s `orderId` field."
  orderId: Int
  "Checks for equality with the object’s `orderDate` field."
  orderDate: Datetime
  "Checks for equality with the object’s `customerId` field."
  customerId: Int
  "Checks for equality with the object’s `totalAmount` field."
  totalAmount: BigFloat
  "Checks for equality with the object’s `paymentMethodId` field."
  paymentMethodId: Int
  "Checks for equality with the object’s `isRefunded` field."
  isRefunded: Boolean
}

"A connection to a list of `OrderItem` values."
type OrderItemsConnection {
  "A list of `OrderItem` objects."
  nodes: [OrderItem]!
  "A list of edges which contains the `OrderItem` and cursor to aid in pagination."
  edges: [OrderItemsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `OrderItem` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ thông tin chi tiết đơn hàng"
type OrderItem implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã chi tiết đơn hàng (khóa chính)"
  orderItemId: Int!
  "Mã đơn hàng (khóa ngoại)"
  orderId: Int
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Số lượng"
  quantity: Int
  "Đơn giá"
  unitPrice: BigFloat
  "Reads a single `Order` that is related to this `OrderItem`."
  orderByOrderId: Order
  "Reads a single `Product` that is related to this `OrderItem`."
  productByProductId: Product
}

"Bảng lưu trữ thông tin sản phẩm"
type Product implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã sản phẩm (khóa chính)"
  productId: Int!
  "Tên sản phẩm"
  productName: String
  "Giá nhập"
  importPrice: BigFloat
  "Giá bán"
  price: BigFloat
  "Số lượng tồn kho"
  stockQuantity: Int
  "Mã danh mục (khóa ngoại)"
  categoryId: Int
  "Đường dẫn tới ảnh sản phẩm"
  publicId: String
  "Reads a single `ProductCategory` that is related to this `Product`."
  productCategoryByCategoryId: ProductCategory
  "Reads and enables pagination through a set of `ProductColorLink`."
  productColorLinksByProductId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductColorLinkCondition): ProductColorLinksConnection!
  "Reads and enables pagination through a set of `ProductSizeLink`."
  productSizeLinksByProductId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductSizeLinkCondition): ProductSizeLinksConnection!
  "Reads and enables pagination through a set of `OrderItem`."
  orderItemsByProductId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: OrderItemCondition): OrderItemsConnection!
}

"Bảng lưu trữ danh mục sản phẩm (loại áo\/quần)"
type ProductCategory implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã danh mục (khóa chính)"
  categoryId: Int!
  "Tên danh mục"
  categoryName: String
  "Loại sản phẩm"
  productType: String
  "Reads and enables pagination through a set of `Product`."
  productsByCategoryId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Product`." orderBy: [ProductsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductCondition): ProductsConnection!
}

"A connection to a list of `Product` values."
type ProductsConnection {
  "A list of `Product` objects."
  nodes: [Product]!
  "A list of edges which contains the `Product` and cursor to aid in pagination."
  edges: [ProductsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Product` you could get from the connection."
  totalCount: Int!
}

"A `Product` edge in the connection."
type ProductsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Product` at the end of the edge."
  node: Product
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: Cursor
  "When paginating forwards, the cursor to continue."
  endCursor: Cursor
}

"Methods to use when ordering `Product`."
enum ProductsOrderBy {
  NATURAL
  PRODUCT_ID_ASC
  PRODUCT_ID_DESC
  PRODUCT_NAME_ASC
  PRODUCT_NAME_DESC
  IMPORT_PRICE_ASC
  IMPORT_PRICE_DESC
  PRICE_ASC
  PRICE_DESC
  STOCK_QUANTITY_ASC
  STOCK_QUANTITY_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  PUBLIC_ID_ASC
  PUBLIC_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ProductCondition {
  "Checks for equality with the object’s `productId` field."
  productId: Int
  "Checks for equality with the object’s `productName` field."
  productName: String
  "Checks for equality with the object’s `importPrice` field."
  importPrice: BigFloat
  "Checks for equality with the object’s `price` field."
  price: BigFloat
  "Checks for equality with the object’s `stockQuantity` field."
  stockQuantity: Int
  "Checks for equality with the object’s `categoryId` field."
  categoryId: Int
  "Checks for equality with the object’s `publicId` field."
  publicId: String
}

"A connection to a list of `ProductColorLink` values."
type ProductColorLinksConnection {
  "A list of `ProductColorLink` objects."
  nodes: [ProductColorLink]!
  "A list of edges which contains the `ProductColorLink` and cursor to aid in pagination."
  edges: [ProductColorLinksEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ProductColorLink` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ liên kết giữa sản phẩm và màu sắc"
type ProductColorLink implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã liên kết (khóa chính)"
  productColorId: Int!
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã màu (khóa ngoại)"
  colorId: Int
  "Reads a single `Product` that is related to this `ProductColorLink`."
  productByProductId: Product
  "Reads a single `ProductColor` that is related to this `ProductColorLink`."
  productColorByColorId: ProductColor
}

"Bảng lưu trữ thông tin màu sắc sản phẩm"
type ProductColor implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã màu (khóa chính)"
  colorId: Int!
  "Tên màu"
  colorName: String
  "Reads and enables pagination through a set of `ProductColorLink`."
  productColorLinksByColorId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductColorLinkCondition): ProductColorLinksConnection!
}

"Methods to use when ordering `ProductColorLink`."
enum ProductColorLinksOrderBy {
  NATURAL
  PRODUCT_COLOR_ID_ASC
  PRODUCT_COLOR_ID_DESC
  PRODUCT_ID_ASC
  PRODUCT_ID_DESC
  COLOR_ID_ASC
  COLOR_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `ProductColorLink` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input ProductColorLinkCondition {
  "Checks for equality with the object’s `productColorId` field."
  productColorId: Int
  "Checks for equality with the object’s `productId` field."
  productId: Int
  "Checks for equality with the object’s `colorId` field."
  colorId: Int
}

"A `ProductColorLink` edge in the connection."
type ProductColorLinksEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ProductColorLink` at the end of the edge."
  node: ProductColorLink
}

"A connection to a list of `ProductSizeLink` values."
type ProductSizeLinksConnection {
  "A list of `ProductSizeLink` objects."
  nodes: [ProductSizeLink]!
  "A list of edges which contains the `ProductSizeLink` and cursor to aid in pagination."
  edges: [ProductSizeLinksEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ProductSizeLink` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ liên kết giữa sản phẩm và kích thước"
type ProductSizeLink implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã liên kết (khóa chính)"
  productSizeId: Int!
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã kích thước (khóa ngoại)"
  sizeId: Int
  "Reads a single `Product` that is related to this `ProductSizeLink`."
  productByProductId: Product
  "Reads a single `ProductSize` that is related to this `ProductSizeLink`."
  productSizeBySizeId: ProductSize
}

"Bảng lưu trữ thông tin kích thước sản phẩm"
type ProductSize implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã kích thước (khóa chính)"
  sizeId: Int!
  "Tên kích thước"
  sizeName: String
  "Reads and enables pagination through a set of `ProductSizeLink`."
  productSizeLinksBySizeId("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: ProductSizeLinkCondition): ProductSizeLinksConnection!
}

"Methods to use when ordering `ProductSizeLink`."
enum ProductSizeLinksOrderBy {
  NATURAL
  PRODUCT_SIZE_ID_ASC
  PRODUCT_SIZE_ID_DESC
  PRODUCT_ID_ASC
  PRODUCT_ID_DESC
  SIZE_ID_ASC
  SIZE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `ProductSizeLink` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input ProductSizeLinkCondition {
  "Checks for equality with the object’s `productSizeId` field."
  productSizeId: Int
  "Checks for equality with the object’s `productId` field."
  productId: Int
  "Checks for equality with the object’s `sizeId` field."
  sizeId: Int
}

"A `ProductSizeLink` edge in the connection."
type ProductSizeLinksEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ProductSizeLink` at the end of the edge."
  node: ProductSizeLink
}

"Methods to use when ordering `OrderItem`."
enum OrderItemsOrderBy {
  NATURAL
  ORDER_ITEM_ID_ASC
  ORDER_ITEM_ID_DESC
  ORDER_ID_ASC
  ORDER_ID_DESC
  PRODUCT_ID_ASC
  PRODUCT_ID_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  UNIT_PRICE_ASC
  UNIT_PRICE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `OrderItem` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input OrderItemCondition {
  "Checks for equality with the object’s `orderItemId` field."
  orderItemId: Int
  "Checks for equality with the object’s `orderId` field."
  orderId: Int
  "Checks for equality with the object’s `productId` field."
  productId: Int
  "Checks for equality with the object’s `quantity` field."
  quantity: Int
  "Checks for equality with the object’s `unitPrice` field."
  unitPrice: BigFloat
}

"A `OrderItem` edge in the connection."
type OrderItemsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `OrderItem` at the end of the edge."
  node: OrderItem
}

"A `Order` edge in the connection."
type OrdersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Order` at the end of the edge."
  node: Order
}

"A `Customer` edge in the connection."
type CustomersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Customer` at the end of the edge."
  node: Customer
}

"Methods to use when ordering `Customer`."
enum CustomersOrderBy {
  NATURAL
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATE_DATE_ASC
  CREATE_DATE_DESC
  POINTS_ASC
  POINTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `Customer` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input CustomerCondition {
  "Checks for equality with the object’s `customerId` field."
  customerId: Int
  "Checks for equality with the object’s `customerName` field."
  customerName: String
  "Checks for equality with the object’s `email` field."
  email: String
  "Checks for equality with the object’s `phone` field."
  phone: String
  "Checks for equality with the object’s `address` field."
  address: String
  "Checks for equality with the object’s `createDate` field."
  createDate: Datetime
  "Checks for equality with the object’s `points` field."
  points: Int
}

"A connection to a list of `PaymentMethod` values."
type PaymentMethodsConnection {
  "A list of `PaymentMethod` objects."
  nodes: [PaymentMethod]!
  "A list of edges which contains the `PaymentMethod` and cursor to aid in pagination."
  edges: [PaymentMethodsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `PaymentMethod` you could get from the connection."
  totalCount: Int!
}

"A `PaymentMethod` edge in the connection."
type PaymentMethodsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `PaymentMethod` at the end of the edge."
  node: PaymentMethod
}

"Methods to use when ordering `PaymentMethod`."
enum PaymentMethodsOrderBy {
  NATURAL
  PAYMENT_METHOD_ID_ASC
  PAYMENT_METHOD_ID_DESC
  PAYMENT_METHOD_NAME_ASC
  PAYMENT_METHOD_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `PaymentMethod` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input PaymentMethodCondition {
  "Checks for equality with the object’s `paymentMethodId` field."
  paymentMethodId: Int
  "Checks for equality with the object’s `paymentMethodName` field."
  paymentMethodName: String
}

"A connection to a list of `ProductCategory` values."
type ProductCategoriesConnection {
  "A list of `ProductCategory` objects."
  nodes: [ProductCategory]!
  "A list of edges which contains the `ProductCategory` and cursor to aid in pagination."
  edges: [ProductCategoriesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ProductCategory` you could get from the connection."
  totalCount: Int!
}

"A `ProductCategory` edge in the connection."
type ProductCategoriesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ProductCategory` at the end of the edge."
  node: ProductCategory
}

"Methods to use when ordering `ProductCategory`."
enum ProductCategoriesOrderBy {
  NATURAL
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  CATEGORY_NAME_ASC
  CATEGORY_NAME_DESC
  PRODUCT_TYPE_ASC
  PRODUCT_TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `ProductCategory` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input ProductCategoryCondition {
  "Checks for equality with the object’s `categoryId` field."
  categoryId: Int
  "Checks for equality with the object’s `categoryName` field."
  categoryName: String
  "Checks for equality with the object’s `productType` field."
  productType: String
}

"A connection to a list of `ProductColor` values."
type ProductColorsConnection {
  "A list of `ProductColor` objects."
  nodes: [ProductColor]!
  "A list of edges which contains the `ProductColor` and cursor to aid in pagination."
  edges: [ProductColorsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ProductColor` you could get from the connection."
  totalCount: Int!
}

"A `ProductColor` edge in the connection."
type ProductColorsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ProductColor` at the end of the edge."
  node: ProductColor
}

"Methods to use when ordering `ProductColor`."
enum ProductColorsOrderBy {
  NATURAL
  COLOR_ID_ASC
  COLOR_ID_DESC
  COLOR_NAME_ASC
  COLOR_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `ProductColor` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input ProductColorCondition {
  "Checks for equality with the object’s `colorId` field."
  colorId: Int
  "Checks for equality with the object’s `colorName` field."
  colorName: String
}

"A connection to a list of `ProductSize` values."
type ProductSizesConnection {
  "A list of `ProductSize` objects."
  nodes: [ProductSize]!
  "A list of edges which contains the `ProductSize` and cursor to aid in pagination."
  edges: [ProductSizesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ProductSize` you could get from the connection."
  totalCount: Int!
}

"A `ProductSize` edge in the connection."
type ProductSizesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ProductSize` at the end of the edge."
  node: ProductSize
}

"Methods to use when ordering `ProductSize`."
enum ProductSizesOrderBy {
  NATURAL
  SIZE_ID_ASC
  SIZE_ID_DESC
  SIZE_NAME_ASC
  SIZE_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `ProductSize` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input ProductSizeCondition {
  "Checks for equality with the object’s `sizeId` field."
  sizeId: Int
  "Checks for equality with the object’s `sizeName` field."
  sizeName: String
}

"A connection to a list of `StoreOwner` values."
type StoreOwnersConnection {
  "A list of `StoreOwner` objects."
  nodes: [StoreOwner]!
  "A list of edges which contains the `StoreOwner` and cursor to aid in pagination."
  edges: [StoreOwnersEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `StoreOwner` you could get from the connection."
  totalCount: Int!
}

"Bảng lưu trữ thông tin chủ cửa hàng"
type StoreOwner implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Mã chủ cửa hàng (khóa chính)"
  ownerId: Int!
  "Tên chủ cửa hàng"
  ownerName: String
  "Email chủ cửa hàng"
  email: String
  "Số điện thoại chủ cửa hàng"
  phone: String
  "Địa chỉ chủ cửa hàng"
  address: String
  "Mật khẩu đã mã hóa"
  password: String
}

"A `StoreOwner` edge in the connection."
type StoreOwnersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `StoreOwner` at the end of the edge."
  node: StoreOwner
}

"Methods to use when ordering `StoreOwner`."
enum StoreOwnersOrderBy {
  NATURAL
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `StoreOwner` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input StoreOwnerCondition {
  "Checks for equality with the object’s `ownerId` field."
  ownerId: Int
  "Checks for equality with the object’s `ownerName` field."
  ownerName: String
  "Checks for equality with the object’s `email` field."
  email: String
  "Checks for equality with the object’s `phone` field."
  phone: String
  "Checks for equality with the object’s `address` field."
  address: String
  "Checks for equality with the object’s `password` field."
  password: String
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
  "Creates a single `Customer`."
  createCustomer("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateCustomerInput!): CreateCustomerPayload
  "Creates a single `Order`."
  createOrder("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateOrderInput!): CreateOrderPayload
  "Creates a single `OrderItem`."
  createOrderItem("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateOrderItemInput!): CreateOrderItemPayload
  "Creates a single `PaymentMethod`."
  createPaymentMethod("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreatePaymentMethodInput!): CreatePaymentMethodPayload
  "Creates a single `Product`."
  createProduct("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductInput!): CreateProductPayload
  "Creates a single `ProductCategory`."
  createProductCategory("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductCategoryInput!): CreateProductCategoryPayload
  "Creates a single `ProductColor`."
  createProductColor("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductColorInput!): CreateProductColorPayload
  "Creates a single `ProductColorLink`."
  createProductColorLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductColorLinkInput!): CreateProductColorLinkPayload
  "Creates a single `ProductSize`."
  createProductSize("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductSizeInput!): CreateProductSizePayload
  "Creates a single `ProductSizeLink`."
  createProductSizeLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateProductSizeLinkInput!): CreateProductSizeLinkPayload
  "Creates a single `StoreOwner`."
  createStoreOwner("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: CreateStoreOwnerInput!): CreateStoreOwnerPayload
  "Updates a single `Customer` using its globally unique id and a patch."
  updateCustomer("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateCustomerInput!): UpdateCustomerPayload
  "Updates a single `Customer` using a unique key and a patch."
  updateCustomerByCustomerId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateCustomerByCustomerIdInput!): UpdateCustomerPayload
  "Updates a single `Order` using its globally unique id and a patch."
  updateOrder("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateOrderInput!): UpdateOrderPayload
  "Updates a single `Order` using a unique key and a patch."
  updateOrderByOrderId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateOrderByOrderIdInput!): UpdateOrderPayload
  "Updates a single `OrderItem` using its globally unique id and a patch."
  updateOrderItem("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateOrderItemInput!): UpdateOrderItemPayload
  "Updates a single `OrderItem` using a unique key and a patch."
  updateOrderItemByOrderItemId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateOrderItemByOrderItemIdInput!): UpdateOrderItemPayload
  "Updates a single `PaymentMethod` using its globally unique id and a patch."
  updatePaymentMethod("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdatePaymentMethodInput!): UpdatePaymentMethodPayload
  "Updates a single `PaymentMethod` using a unique key and a patch."
  updatePaymentMethodByPaymentMethodId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdatePaymentMethodByPaymentMethodIdInput!): UpdatePaymentMethodPayload
  "Updates a single `Product` using its globally unique id and a patch."
  updateProduct("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductInput!): UpdateProductPayload
  "Updates a single `Product` using a unique key and a patch."
  updateProductByProductId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductByProductIdInput!): UpdateProductPayload
  "Updates a single `ProductCategory` using its globally unique id and a patch."
  updateProductCategory("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductCategoryInput!): UpdateProductCategoryPayload
  "Updates a single `ProductCategory` using a unique key and a patch."
  updateProductCategoryByCategoryId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductCategoryByCategoryIdInput!): UpdateProductCategoryPayload
  "Updates a single `ProductColor` using its globally unique id and a patch."
  updateProductColor("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductColorInput!): UpdateProductColorPayload
  "Updates a single `ProductColor` using a unique key and a patch."
  updateProductColorByColorId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductColorByColorIdInput!): UpdateProductColorPayload
  "Updates a single `ProductColorLink` using its globally unique id and a patch."
  updateProductColorLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductColorLinkInput!): UpdateProductColorLinkPayload
  "Updates a single `ProductColorLink` using a unique key and a patch."
  updateProductColorLinkByProductColorId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductColorLinkByProductColorIdInput!): UpdateProductColorLinkPayload
  "Updates a single `ProductSize` using its globally unique id and a patch."
  updateProductSize("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductSizeInput!): UpdateProductSizePayload
  "Updates a single `ProductSize` using a unique key and a patch."
  updateProductSizeBySizeId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductSizeBySizeIdInput!): UpdateProductSizePayload
  "Updates a single `ProductSizeLink` using its globally unique id and a patch."
  updateProductSizeLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductSizeLinkInput!): UpdateProductSizeLinkPayload
  "Updates a single `ProductSizeLink` using a unique key and a patch."
  updateProductSizeLinkByProductSizeId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateProductSizeLinkByProductSizeIdInput!): UpdateProductSizeLinkPayload
  "Updates a single `StoreOwner` using its globally unique id and a patch."
  updateStoreOwner("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateStoreOwnerInput!): UpdateStoreOwnerPayload
  "Updates a single `StoreOwner` using a unique key and a patch."
  updateStoreOwnerByOwnerId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateStoreOwnerByOwnerIdInput!): UpdateStoreOwnerPayload
  "Deletes a single `Customer` using its globally unique id."
  deleteCustomer("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteCustomerInput!): DeleteCustomerPayload
  "Deletes a single `Customer` using a unique key."
  deleteCustomerByCustomerId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteCustomerByCustomerIdInput!): DeleteCustomerPayload
  "Deletes a single `Order` using its globally unique id."
  deleteOrder("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteOrderInput!): DeleteOrderPayload
  "Deletes a single `Order` using a unique key."
  deleteOrderByOrderId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteOrderByOrderIdInput!): DeleteOrderPayload
  "Deletes a single `OrderItem` using its globally unique id."
  deleteOrderItem("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteOrderItemInput!): DeleteOrderItemPayload
  "Deletes a single `OrderItem` using a unique key."
  deleteOrderItemByOrderItemId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteOrderItemByOrderItemIdInput!): DeleteOrderItemPayload
  "Deletes a single `PaymentMethod` using its globally unique id."
  deletePaymentMethod("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeletePaymentMethodInput!): DeletePaymentMethodPayload
  "Deletes a single `PaymentMethod` using a unique key."
  deletePaymentMethodByPaymentMethodId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeletePaymentMethodByPaymentMethodIdInput!): DeletePaymentMethodPayload
  "Deletes a single `Product` using its globally unique id."
  deleteProduct("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductInput!): DeleteProductPayload
  "Deletes a single `Product` using a unique key."
  deleteProductByProductId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductByProductIdInput!): DeleteProductPayload
  "Deletes a single `ProductCategory` using its globally unique id."
  deleteProductCategory("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductCategoryInput!): DeleteProductCategoryPayload
  "Deletes a single `ProductCategory` using a unique key."
  deleteProductCategoryByCategoryId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductCategoryByCategoryIdInput!): DeleteProductCategoryPayload
  "Deletes a single `ProductColor` using its globally unique id."
  deleteProductColor("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductColorInput!): DeleteProductColorPayload
  "Deletes a single `ProductColor` using a unique key."
  deleteProductColorByColorId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductColorByColorIdInput!): DeleteProductColorPayload
  "Deletes a single `ProductColorLink` using its globally unique id."
  deleteProductColorLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductColorLinkInput!): DeleteProductColorLinkPayload
  "Deletes a single `ProductColorLink` using a unique key."
  deleteProductColorLinkByProductColorId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductColorLinkByProductColorIdInput!): DeleteProductColorLinkPayload
  "Deletes a single `ProductSize` using its globally unique id."
  deleteProductSize("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductSizeInput!): DeleteProductSizePayload
  "Deletes a single `ProductSize` using a unique key."
  deleteProductSizeBySizeId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductSizeBySizeIdInput!): DeleteProductSizePayload
  "Deletes a single `ProductSizeLink` using its globally unique id."
  deleteProductSizeLink("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductSizeLinkInput!): DeleteProductSizeLinkPayload
  "Deletes a single `ProductSizeLink` using a unique key."
  deleteProductSizeLinkByProductSizeId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteProductSizeLinkByProductSizeIdInput!): DeleteProductSizeLinkPayload
  "Deletes a single `StoreOwner` using its globally unique id."
  deleteStoreOwner("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteStoreOwnerInput!): DeleteStoreOwnerPayload
  "Deletes a single `StoreOwner` using a unique key."
  deleteStoreOwnerByOwnerId("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: DeleteStoreOwnerByOwnerIdInput!): DeleteStoreOwnerPayload
}

"The output of our create `Customer` mutation."
type CreateCustomerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Customer` that was created by this mutation."
  customer: Customer
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `Customer`. May be used by Relay 1."
  customerEdge("The method to use when ordering `Customer`." orderBy: [CustomersOrderBy!] = [ PRIMARY_KEY_ASC ]): CustomersEdge
}

"All input for the create `Customer` mutation."
input CreateCustomerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Customer` to be created by this mutation."
  customer: CustomerInput!
}

"An input for mutations affecting `Customer`"
input CustomerInput {
  "Mã khách hàng (khóa chính)"
  customerId: Int!
  "Tên khách hàng"
  customerName: String
  "Email khách hàng"
  email: String
  "Số điện thoại khách hàng"
  phone: String
  "Địa chỉ khách hàng"
  address: String
  "Ngày tạo tài khoản"
  createDate: Datetime
  "Điểm tích lũy"
  points: Int
}

"The output of our create `Order` mutation."
type CreateOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Order` that was created by this mutation."
  order: Order
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Customer` that is related to this `Order`."
  customerByCustomerId: Customer
  "Reads a single `PaymentMethod` that is related to this `Order`."
  paymentMethodByPaymentMethodId: PaymentMethod
  "An edge for our `Order`. May be used by Relay 1."
  orderEdge("The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ]): OrdersEdge
}

"All input for the create `Order` mutation."
input CreateOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Order` to be created by this mutation."
  order: OrderInput!
}

"An input for mutations affecting `Order`"
input OrderInput {
  "Mã đơn hàng (khóa chính)"
  orderId: Int!
  "Ngày đặt hàng"
  orderDate: Datetime
  "Mã khách hàng (khóa ngoại)"
  customerId: Int
  "Tổng số tiền"
  totalAmount: BigFloat
  "Mã phương thức thanh toán (khóa ngoại)"
  paymentMethodId: Int
  "Trạng thái hoàn tiền"
  isRefunded: Boolean
}

"The output of our create `OrderItem` mutation."
type CreateOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `OrderItem` that was created by this mutation."
  orderItem: OrderItem
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Order` that is related to this `OrderItem`."
  orderByOrderId: Order
  "Reads a single `Product` that is related to this `OrderItem`."
  productByProductId: Product
  "An edge for our `OrderItem`. May be used by Relay 1."
  orderItemEdge("The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ]): OrderItemsEdge
}

"All input for the create `OrderItem` mutation."
input CreateOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `OrderItem` to be created by this mutation."
  orderItem: OrderItemInput!
}

"An input for mutations affecting `OrderItem`"
input OrderItemInput {
  "Mã chi tiết đơn hàng (khóa chính)"
  orderItemId: Int!
  "Mã đơn hàng (khóa ngoại)"
  orderId: Int
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Số lượng"
  quantity: Int
  "Đơn giá"
  unitPrice: BigFloat
}

"The output of our create `PaymentMethod` mutation."
type CreatePaymentMethodPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `PaymentMethod` that was created by this mutation."
  paymentMethod: PaymentMethod
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `PaymentMethod`. May be used by Relay 1."
  paymentMethodEdge("The method to use when ordering `PaymentMethod`." orderBy: [PaymentMethodsOrderBy!] = [ PRIMARY_KEY_ASC ]): PaymentMethodsEdge
}

"All input for the create `PaymentMethod` mutation."
input CreatePaymentMethodInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `PaymentMethod` to be created by this mutation."
  paymentMethod: PaymentMethodInput!
}

"An input for mutations affecting `PaymentMethod`"
input PaymentMethodInput {
  "Mã phương thức thanh toán (khóa chính)"
  paymentMethodId: Int!
  "Tên phương thức thanh toán"
  paymentMethodName: String
}

"The output of our create `Product` mutation."
type CreateProductPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Product` that was created by this mutation."
  product: Product
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `ProductCategory` that is related to this `Product`."
  productCategoryByCategoryId: ProductCategory
  "An edge for our `Product`. May be used by Relay 1."
  productEdge("The method to use when ordering `Product`." orderBy: [ProductsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductsEdge
}

"All input for the create `Product` mutation."
input CreateProductInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Product` to be created by this mutation."
  product: ProductInput!
}

"An input for mutations affecting `Product`"
input ProductInput {
  "Mã sản phẩm (khóa chính)"
  productId: Int!
  "Tên sản phẩm"
  productName: String
  "Giá nhập"
  importPrice: BigFloat
  "Giá bán"
  price: BigFloat
  "Số lượng tồn kho"
  stockQuantity: Int
  "Mã danh mục (khóa ngoại)"
  categoryId: Int
  "Đường dẫn tới ảnh sản phẩm"
  publicId: String
}

"The output of our create `ProductCategory` mutation."
type CreateProductCategoryPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductCategory` that was created by this mutation."
  productCategory: ProductCategory
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductCategory`. May be used by Relay 1."
  productCategoryEdge("The method to use when ordering `ProductCategory`." orderBy: [ProductCategoriesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductCategoriesEdge
}

"All input for the create `ProductCategory` mutation."
input CreateProductCategoryInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ProductCategory` to be created by this mutation."
  productCategory: ProductCategoryInput!
}

"An input for mutations affecting `ProductCategory`"
input ProductCategoryInput {
  "Mã danh mục (khóa chính)"
  categoryId: Int!
  "Tên danh mục"
  categoryName: String
  "Loại sản phẩm"
  productType: String
}

"The output of our create `ProductColor` mutation."
type CreateProductColorPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColor` that was created by this mutation."
  productColor: ProductColor
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductColor`. May be used by Relay 1."
  productColorEdge("The method to use when ordering `ProductColor`." orderBy: [ProductColorsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorsEdge
}

"All input for the create `ProductColor` mutation."
input CreateProductColorInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ProductColor` to be created by this mutation."
  productColor: ProductColorInput!
}

"An input for mutations affecting `ProductColor`"
input ProductColorInput {
  "Mã màu (khóa chính)"
  colorId: Int!
  "Tên màu"
  colorName: String
}

"The output of our create `ProductColorLink` mutation."
type CreateProductColorLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColorLink` that was created by this mutation."
  productColorLink: ProductColorLink
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductColorLink`."
  productByProductId: Product
  "Reads a single `ProductColor` that is related to this `ProductColorLink`."
  productColorByColorId: ProductColor
  "An edge for our `ProductColorLink`. May be used by Relay 1."
  productColorLinkEdge("The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorLinksEdge
}

"All input for the create `ProductColorLink` mutation."
input CreateProductColorLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ProductColorLink` to be created by this mutation."
  productColorLink: ProductColorLinkInput!
}

"An input for mutations affecting `ProductColorLink`"
input ProductColorLinkInput {
  "Mã liên kết (khóa chính)"
  productColorId: Int!
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã màu (khóa ngoại)"
  colorId: Int
}

"The output of our create `ProductSize` mutation."
type CreateProductSizePayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSize` that was created by this mutation."
  productSize: ProductSize
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductSize`. May be used by Relay 1."
  productSizeEdge("The method to use when ordering `ProductSize`." orderBy: [ProductSizesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizesEdge
}

"All input for the create `ProductSize` mutation."
input CreateProductSizeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ProductSize` to be created by this mutation."
  productSize: ProductSizeInput!
}

"An input for mutations affecting `ProductSize`"
input ProductSizeInput {
  "Mã kích thước (khóa chính)"
  sizeId: Int!
  "Tên kích thước"
  sizeName: String
}

"The output of our create `ProductSizeLink` mutation."
type CreateProductSizeLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSizeLink` that was created by this mutation."
  productSizeLink: ProductSizeLink
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductSizeLink`."
  productByProductId: Product
  "Reads a single `ProductSize` that is related to this `ProductSizeLink`."
  productSizeBySizeId: ProductSize
  "An edge for our `ProductSizeLink`. May be used by Relay 1."
  productSizeLinkEdge("The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizeLinksEdge
}

"All input for the create `ProductSizeLink` mutation."
input CreateProductSizeLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ProductSizeLink` to be created by this mutation."
  productSizeLink: ProductSizeLinkInput!
}

"An input for mutations affecting `ProductSizeLink`"
input ProductSizeLinkInput {
  "Mã liên kết (khóa chính)"
  productSizeId: Int!
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã kích thước (khóa ngoại)"
  sizeId: Int
}

"The output of our create `StoreOwner` mutation."
type CreateStoreOwnerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `StoreOwner` that was created by this mutation."
  storeOwner: StoreOwner
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `StoreOwner`. May be used by Relay 1."
  storeOwnerEdge("The method to use when ordering `StoreOwner`." orderBy: [StoreOwnersOrderBy!] = [ PRIMARY_KEY_ASC ]): StoreOwnersEdge
}

"All input for the create `StoreOwner` mutation."
input CreateStoreOwnerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `StoreOwner` to be created by this mutation."
  storeOwner: StoreOwnerInput!
}

"An input for mutations affecting `StoreOwner`"
input StoreOwnerInput {
  "Mã chủ cửa hàng (khóa chính)"
  ownerId: Int!
  "Tên chủ cửa hàng"
  ownerName: String
  "Email chủ cửa hàng"
  email: String
  "Số điện thoại chủ cửa hàng"
  phone: String
  "Địa chỉ chủ cửa hàng"
  address: String
  "Mật khẩu đã mã hóa"
  password: String
}

"The output of our update `Customer` mutation."
type UpdateCustomerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Customer` that was updated by this mutation."
  customer: Customer
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `Customer`. May be used by Relay 1."
  customerEdge("The method to use when ordering `Customer`." orderBy: [CustomersOrderBy!] = [ PRIMARY_KEY_ASC ]): CustomersEdge
}

"All input for the `updateCustomer` mutation."
input UpdateCustomerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Customer` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Customer` being updated."
  customerPatch: CustomerPatch!
}

"Represents an update to a `Customer`. Fields that are set will be updated."
input CustomerPatch {
  "Mã khách hàng (khóa chính)"
  customerId: Int
  "Tên khách hàng"
  customerName: String
  "Email khách hàng"
  email: String
  "Số điện thoại khách hàng"
  phone: String
  "Địa chỉ khách hàng"
  address: String
  "Ngày tạo tài khoản"
  createDate: Datetime
  "Điểm tích lũy"
  points: Int
}

"All input for the `updateCustomerByCustomerId` mutation."
input UpdateCustomerByCustomerIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `Customer` being updated."
  customerPatch: CustomerPatch!
  "Mã khách hàng (khóa chính)"
  customerId: Int!
}

"The output of our update `Order` mutation."
type UpdateOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Order` that was updated by this mutation."
  order: Order
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Customer` that is related to this `Order`."
  customerByCustomerId: Customer
  "Reads a single `PaymentMethod` that is related to this `Order`."
  paymentMethodByPaymentMethodId: PaymentMethod
  "An edge for our `Order`. May be used by Relay 1."
  orderEdge("The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ]): OrdersEdge
}

"All input for the `updateOrder` mutation."
input UpdateOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Order` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Order` being updated."
  orderPatch: OrderPatch!
}

"Represents an update to a `Order`. Fields that are set will be updated."
input OrderPatch {
  "Mã đơn hàng (khóa chính)"
  orderId: Int
  "Ngày đặt hàng"
  orderDate: Datetime
  "Mã khách hàng (khóa ngoại)"
  customerId: Int
  "Tổng số tiền"
  totalAmount: BigFloat
  "Mã phương thức thanh toán (khóa ngoại)"
  paymentMethodId: Int
  "Trạng thái hoàn tiền"
  isRefunded: Boolean
}

"All input for the `updateOrderByOrderId` mutation."
input UpdateOrderByOrderIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `Order` being updated."
  orderPatch: OrderPatch!
  "Mã đơn hàng (khóa chính)"
  orderId: Int!
}

"The output of our update `OrderItem` mutation."
type UpdateOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `OrderItem` that was updated by this mutation."
  orderItem: OrderItem
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Order` that is related to this `OrderItem`."
  orderByOrderId: Order
  "Reads a single `Product` that is related to this `OrderItem`."
  productByProductId: Product
  "An edge for our `OrderItem`. May be used by Relay 1."
  orderItemEdge("The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ]): OrderItemsEdge
}

"All input for the `updateOrderItem` mutation."
input UpdateOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `OrderItem` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `OrderItem` being updated."
  orderItemPatch: OrderItemPatch!
}

"Represents an update to a `OrderItem`. Fields that are set will be updated."
input OrderItemPatch {
  "Mã chi tiết đơn hàng (khóa chính)"
  orderItemId: Int
  "Mã đơn hàng (khóa ngoại)"
  orderId: Int
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Số lượng"
  quantity: Int
  "Đơn giá"
  unitPrice: BigFloat
}

"All input for the `updateOrderItemByOrderItemId` mutation."
input UpdateOrderItemByOrderItemIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `OrderItem` being updated."
  orderItemPatch: OrderItemPatch!
  "Mã chi tiết đơn hàng (khóa chính)"
  orderItemId: Int!
}

"The output of our update `PaymentMethod` mutation."
type UpdatePaymentMethodPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `PaymentMethod` that was updated by this mutation."
  paymentMethod: PaymentMethod
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `PaymentMethod`. May be used by Relay 1."
  paymentMethodEdge("The method to use when ordering `PaymentMethod`." orderBy: [PaymentMethodsOrderBy!] = [ PRIMARY_KEY_ASC ]): PaymentMethodsEdge
}

"All input for the `updatePaymentMethod` mutation."
input UpdatePaymentMethodInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `PaymentMethod` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `PaymentMethod` being updated."
  paymentMethodPatch: PaymentMethodPatch!
}

"Represents an update to a `PaymentMethod`. Fields that are set will be updated."
input PaymentMethodPatch {
  "Mã phương thức thanh toán (khóa chính)"
  paymentMethodId: Int
  "Tên phương thức thanh toán"
  paymentMethodName: String
}

"All input for the `updatePaymentMethodByPaymentMethodId` mutation."
input UpdatePaymentMethodByPaymentMethodIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `PaymentMethod` being updated."
  paymentMethodPatch: PaymentMethodPatch!
  "Mã phương thức thanh toán (khóa chính)"
  paymentMethodId: Int!
}

"The output of our update `Product` mutation."
type UpdateProductPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Product` that was updated by this mutation."
  product: Product
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `ProductCategory` that is related to this `Product`."
  productCategoryByCategoryId: ProductCategory
  "An edge for our `Product`. May be used by Relay 1."
  productEdge("The method to use when ordering `Product`." orderBy: [ProductsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductsEdge
}

"All input for the `updateProduct` mutation."
input UpdateProductInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Product` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Product` being updated."
  productPatch: ProductPatch!
}

"Represents an update to a `Product`. Fields that are set will be updated."
input ProductPatch {
  "Mã sản phẩm (khóa chính)"
  productId: Int
  "Tên sản phẩm"
  productName: String
  "Giá nhập"
  importPrice: BigFloat
  "Giá bán"
  price: BigFloat
  "Số lượng tồn kho"
  stockQuantity: Int
  "Mã danh mục (khóa ngoại)"
  categoryId: Int
  "Đường dẫn tới ảnh sản phẩm"
  publicId: String
}

"All input for the `updateProductByProductId` mutation."
input UpdateProductByProductIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `Product` being updated."
  productPatch: ProductPatch!
  "Mã sản phẩm (khóa chính)"
  productId: Int!
}

"The output of our update `ProductCategory` mutation."
type UpdateProductCategoryPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductCategory` that was updated by this mutation."
  productCategory: ProductCategory
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductCategory`. May be used by Relay 1."
  productCategoryEdge("The method to use when ordering `ProductCategory`." orderBy: [ProductCategoriesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductCategoriesEdge
}

"All input for the `updateProductCategory` mutation."
input UpdateProductCategoryInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductCategory` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ProductCategory` being updated."
  productCategoryPatch: ProductCategoryPatch!
}

"Represents an update to a `ProductCategory`. Fields that are set will be updated."
input ProductCategoryPatch {
  "Mã danh mục (khóa chính)"
  categoryId: Int
  "Tên danh mục"
  categoryName: String
  "Loại sản phẩm"
  productType: String
}

"All input for the `updateProductCategoryByCategoryId` mutation."
input UpdateProductCategoryByCategoryIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `ProductCategory` being updated."
  productCategoryPatch: ProductCategoryPatch!
  "Mã danh mục (khóa chính)"
  categoryId: Int!
}

"The output of our update `ProductColor` mutation."
type UpdateProductColorPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColor` that was updated by this mutation."
  productColor: ProductColor
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductColor`. May be used by Relay 1."
  productColorEdge("The method to use when ordering `ProductColor`." orderBy: [ProductColorsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorsEdge
}

"All input for the `updateProductColor` mutation."
input UpdateProductColorInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductColor` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ProductColor` being updated."
  productColorPatch: ProductColorPatch!
}

"Represents an update to a `ProductColor`. Fields that are set will be updated."
input ProductColorPatch {
  "Mã màu (khóa chính)"
  colorId: Int
  "Tên màu"
  colorName: String
}

"All input for the `updateProductColorByColorId` mutation."
input UpdateProductColorByColorIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `ProductColor` being updated."
  productColorPatch: ProductColorPatch!
  "Mã màu (khóa chính)"
  colorId: Int!
}

"The output of our update `ProductColorLink` mutation."
type UpdateProductColorLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColorLink` that was updated by this mutation."
  productColorLink: ProductColorLink
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductColorLink`."
  productByProductId: Product
  "Reads a single `ProductColor` that is related to this `ProductColorLink`."
  productColorByColorId: ProductColor
  "An edge for our `ProductColorLink`. May be used by Relay 1."
  productColorLinkEdge("The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorLinksEdge
}

"All input for the `updateProductColorLink` mutation."
input UpdateProductColorLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductColorLink` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ProductColorLink` being updated."
  productColorLinkPatch: ProductColorLinkPatch!
}

"Represents an update to a `ProductColorLink`. Fields that are set will be updated."
input ProductColorLinkPatch {
  "Mã liên kết (khóa chính)"
  productColorId: Int
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã màu (khóa ngoại)"
  colorId: Int
}

"All input for the `updateProductColorLinkByProductColorId` mutation."
input UpdateProductColorLinkByProductColorIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `ProductColorLink` being updated."
  productColorLinkPatch: ProductColorLinkPatch!
  "Mã liên kết (khóa chính)"
  productColorId: Int!
}

"The output of our update `ProductSize` mutation."
type UpdateProductSizePayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSize` that was updated by this mutation."
  productSize: ProductSize
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductSize`. May be used by Relay 1."
  productSizeEdge("The method to use when ordering `ProductSize`." orderBy: [ProductSizesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizesEdge
}

"All input for the `updateProductSize` mutation."
input UpdateProductSizeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductSize` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ProductSize` being updated."
  productSizePatch: ProductSizePatch!
}

"Represents an update to a `ProductSize`. Fields that are set will be updated."
input ProductSizePatch {
  "Mã kích thước (khóa chính)"
  sizeId: Int
  "Tên kích thước"
  sizeName: String
}

"All input for the `updateProductSizeBySizeId` mutation."
input UpdateProductSizeBySizeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `ProductSize` being updated."
  productSizePatch: ProductSizePatch!
  "Mã kích thước (khóa chính)"
  sizeId: Int!
}

"The output of our update `ProductSizeLink` mutation."
type UpdateProductSizeLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSizeLink` that was updated by this mutation."
  productSizeLink: ProductSizeLink
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductSizeLink`."
  productByProductId: Product
  "Reads a single `ProductSize` that is related to this `ProductSizeLink`."
  productSizeBySizeId: ProductSize
  "An edge for our `ProductSizeLink`. May be used by Relay 1."
  productSizeLinkEdge("The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizeLinksEdge
}

"All input for the `updateProductSizeLink` mutation."
input UpdateProductSizeLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductSizeLink` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ProductSizeLink` being updated."
  productSizeLinkPatch: ProductSizeLinkPatch!
}

"Represents an update to a `ProductSizeLink`. Fields that are set will be updated."
input ProductSizeLinkPatch {
  "Mã liên kết (khóa chính)"
  productSizeId: Int
  "Mã sản phẩm (khóa ngoại)"
  productId: Int
  "Mã kích thước (khóa ngoại)"
  sizeId: Int
}

"All input for the `updateProductSizeLinkByProductSizeId` mutation."
input UpdateProductSizeLinkByProductSizeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `ProductSizeLink` being updated."
  productSizeLinkPatch: ProductSizeLinkPatch!
  "Mã liên kết (khóa chính)"
  productSizeId: Int!
}

"The output of our update `StoreOwner` mutation."
type UpdateStoreOwnerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `StoreOwner` that was updated by this mutation."
  storeOwner: StoreOwner
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `StoreOwner`. May be used by Relay 1."
  storeOwnerEdge("The method to use when ordering `StoreOwner`." orderBy: [StoreOwnersOrderBy!] = [ PRIMARY_KEY_ASC ]): StoreOwnersEdge
}

"All input for the `updateStoreOwner` mutation."
input UpdateStoreOwnerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `StoreOwner` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `StoreOwner` being updated."
  storeOwnerPatch: StoreOwnerPatch!
}

"Represents an update to a `StoreOwner`. Fields that are set will be updated."
input StoreOwnerPatch {
  "Mã chủ cửa hàng (khóa chính)"
  ownerId: Int
  "Tên chủ cửa hàng"
  ownerName: String
  "Email chủ cửa hàng"
  email: String
  "Số điện thoại chủ cửa hàng"
  phone: String
  "Địa chỉ chủ cửa hàng"
  address: String
  "Mật khẩu đã mã hóa"
  password: String
}

"All input for the `updateStoreOwnerByOwnerId` mutation."
input UpdateStoreOwnerByOwnerIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `StoreOwner` being updated."
  storeOwnerPatch: StoreOwnerPatch!
  "Mã chủ cửa hàng (khóa chính)"
  ownerId: Int!
}

"The output of our delete `Customer` mutation."
type DeleteCustomerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Customer` that was deleted by this mutation."
  customer: Customer
  deletedCustomerId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `Customer`. May be used by Relay 1."
  customerEdge("The method to use when ordering `Customer`." orderBy: [CustomersOrderBy!] = [ PRIMARY_KEY_ASC ]): CustomersEdge
}

"All input for the `deleteCustomer` mutation."
input DeleteCustomerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Customer` to be deleted."
  nodeId: ID!
}

"All input for the `deleteCustomerByCustomerId` mutation."
input DeleteCustomerByCustomerIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã khách hàng (khóa chính)"
  customerId: Int!
}

"The output of our delete `Order` mutation."
type DeleteOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Order` that was deleted by this mutation."
  order: Order
  deletedOrderId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Customer` that is related to this `Order`."
  customerByCustomerId: Customer
  "Reads a single `PaymentMethod` that is related to this `Order`."
  paymentMethodByPaymentMethodId: PaymentMethod
  "An edge for our `Order`. May be used by Relay 1."
  orderEdge("The method to use when ordering `Order`." orderBy: [OrdersOrderBy!] = [ PRIMARY_KEY_ASC ]): OrdersEdge
}

"All input for the `deleteOrder` mutation."
input DeleteOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Order` to be deleted."
  nodeId: ID!
}

"All input for the `deleteOrderByOrderId` mutation."
input DeleteOrderByOrderIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã đơn hàng (khóa chính)"
  orderId: Int!
}

"The output of our delete `OrderItem` mutation."
type DeleteOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `OrderItem` that was deleted by this mutation."
  orderItem: OrderItem
  deletedOrderItemId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Order` that is related to this `OrderItem`."
  orderByOrderId: Order
  "Reads a single `Product` that is related to this `OrderItem`."
  productByProductId: Product
  "An edge for our `OrderItem`. May be used by Relay 1."
  orderItemEdge("The method to use when ordering `OrderItem`." orderBy: [OrderItemsOrderBy!] = [ PRIMARY_KEY_ASC ]): OrderItemsEdge
}

"All input for the `deleteOrderItem` mutation."
input DeleteOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `OrderItem` to be deleted."
  nodeId: ID!
}

"All input for the `deleteOrderItemByOrderItemId` mutation."
input DeleteOrderItemByOrderItemIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã chi tiết đơn hàng (khóa chính)"
  orderItemId: Int!
}

"The output of our delete `PaymentMethod` mutation."
type DeletePaymentMethodPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `PaymentMethod` that was deleted by this mutation."
  paymentMethod: PaymentMethod
  deletedPaymentMethodId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `PaymentMethod`. May be used by Relay 1."
  paymentMethodEdge("The method to use when ordering `PaymentMethod`." orderBy: [PaymentMethodsOrderBy!] = [ PRIMARY_KEY_ASC ]): PaymentMethodsEdge
}

"All input for the `deletePaymentMethod` mutation."
input DeletePaymentMethodInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `PaymentMethod` to be deleted."
  nodeId: ID!
}

"All input for the `deletePaymentMethodByPaymentMethodId` mutation."
input DeletePaymentMethodByPaymentMethodIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã phương thức thanh toán (khóa chính)"
  paymentMethodId: Int!
}

"The output of our delete `Product` mutation."
type DeleteProductPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Product` that was deleted by this mutation."
  product: Product
  deletedProductId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `ProductCategory` that is related to this `Product`."
  productCategoryByCategoryId: ProductCategory
  "An edge for our `Product`. May be used by Relay 1."
  productEdge("The method to use when ordering `Product`." orderBy: [ProductsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductsEdge
}

"All input for the `deleteProduct` mutation."
input DeleteProductInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Product` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductByProductId` mutation."
input DeleteProductByProductIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã sản phẩm (khóa chính)"
  productId: Int!
}

"The output of our delete `ProductCategory` mutation."
type DeleteProductCategoryPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductCategory` that was deleted by this mutation."
  productCategory: ProductCategory
  deletedProductCategoryId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductCategory`. May be used by Relay 1."
  productCategoryEdge("The method to use when ordering `ProductCategory`." orderBy: [ProductCategoriesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductCategoriesEdge
}

"All input for the `deleteProductCategory` mutation."
input DeleteProductCategoryInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductCategory` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductCategoryByCategoryId` mutation."
input DeleteProductCategoryByCategoryIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã danh mục (khóa chính)"
  categoryId: Int!
}

"The output of our delete `ProductColor` mutation."
type DeleteProductColorPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColor` that was deleted by this mutation."
  productColor: ProductColor
  deletedProductColorId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductColor`. May be used by Relay 1."
  productColorEdge("The method to use when ordering `ProductColor`." orderBy: [ProductColorsOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorsEdge
}

"All input for the `deleteProductColor` mutation."
input DeleteProductColorInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductColor` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductColorByColorId` mutation."
input DeleteProductColorByColorIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã màu (khóa chính)"
  colorId: Int!
}

"The output of our delete `ProductColorLink` mutation."
type DeleteProductColorLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductColorLink` that was deleted by this mutation."
  productColorLink: ProductColorLink
  deletedProductColorLinkId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductColorLink`."
  productByProductId: Product
  "Reads a single `ProductColor` that is related to this `ProductColorLink`."
  productColorByColorId: ProductColor
  "An edge for our `ProductColorLink`. May be used by Relay 1."
  productColorLinkEdge("The method to use when ordering `ProductColorLink`." orderBy: [ProductColorLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductColorLinksEdge
}

"All input for the `deleteProductColorLink` mutation."
input DeleteProductColorLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductColorLink` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductColorLinkByProductColorId` mutation."
input DeleteProductColorLinkByProductColorIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã liên kết (khóa chính)"
  productColorId: Int!
}

"The output of our delete `ProductSize` mutation."
type DeleteProductSizePayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSize` that was deleted by this mutation."
  productSize: ProductSize
  deletedProductSizeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `ProductSize`. May be used by Relay 1."
  productSizeEdge("The method to use when ordering `ProductSize`." orderBy: [ProductSizesOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizesEdge
}

"All input for the `deleteProductSize` mutation."
input DeleteProductSizeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductSize` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductSizeBySizeId` mutation."
input DeleteProductSizeBySizeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã kích thước (khóa chính)"
  sizeId: Int!
}

"The output of our delete `ProductSizeLink` mutation."
type DeleteProductSizeLinkPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `ProductSizeLink` that was deleted by this mutation."
  productSizeLink: ProductSizeLink
  deletedProductSizeLinkId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Product` that is related to this `ProductSizeLink`."
  productByProductId: Product
  "Reads a single `ProductSize` that is related to this `ProductSizeLink`."
  productSizeBySizeId: ProductSize
  "An edge for our `ProductSizeLink`. May be used by Relay 1."
  productSizeLinkEdge("The method to use when ordering `ProductSizeLink`." orderBy: [ProductSizeLinksOrderBy!] = [ PRIMARY_KEY_ASC ]): ProductSizeLinksEdge
}

"All input for the `deleteProductSizeLink` mutation."
input DeleteProductSizeLinkInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ProductSizeLink` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProductSizeLinkByProductSizeId` mutation."
input DeleteProductSizeLinkByProductSizeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã liên kết (khóa chính)"
  productSizeId: Int!
}

"The output of our delete `StoreOwner` mutation."
type DeleteStoreOwnerPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `StoreOwner` that was deleted by this mutation."
  storeOwner: StoreOwner
  deletedStoreOwnerId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "An edge for our `StoreOwner`. May be used by Relay 1."
  storeOwnerEdge("The method to use when ordering `StoreOwner`." orderBy: [StoreOwnersOrderBy!] = [ PRIMARY_KEY_ASC ]): StoreOwnersEdge
}

"All input for the `deleteStoreOwner` mutation."
input DeleteStoreOwnerInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `StoreOwner` to be deleted."
  nodeId: ID!
}

"All input for the `deleteStoreOwnerByOwnerId` mutation."
input DeleteStoreOwnerByOwnerIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "Mã chủ cửa hàng (khóa chính)"
  ownerId: Int!
}